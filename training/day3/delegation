//delegation
// with delegation , you can plug in more the one inheritance
// from multiple clas or interface


fun main(){

}

// class App: firstDelegate:A:B // it in not allowed

//  interface used by firstDelegate class
class App: A by FirstDelegate(),B by SecondDelegate(){
    override fun print() {

    }
    override fun print2(){

    }
    val myPowerBank = PowerBank()
    val myPhone = Phone(myPowerBank)

    myPhone.makeCall()     // ğŸ“ Calling... Battery: 50%
    myPhone.charge()       // ğŸ”‹ PowerBank: Fully charged!
    myPhone.makeCall()     // ğŸ“ Calling... Battery: 100%

}

interface A{
    fun print()
}
interface B{
    fun print2()
}

class FirstDelegate:A{
    override fun print() {}
}

class SecondDelegate: B{
    override fun print() {}
}


// Interface = What a battery can DO
interface Battery {
    fun charge()
    fun getLevel(): Int
}

// Class = Actual implementation
class PowerBank : Battery {
    private var level = 50

    override fun charge() {
        level = 100
        println("ğŸ”‹ PowerBank: Fully charged!")
    }

    override fun getLevel() = level
}

// Phone DELEGATES battery functions to PowerBank
class Phone(battery: Battery) : Battery by battery {
    fun makeCall() {
        if (getLevel() > 20) {  // Uses DELEGATED getLevel()
            println("ğŸ“ Calling... Battery: ${getLevel()}%")
        } else {
            println("âš ï¸ Low battery!")
        }
    }
}

