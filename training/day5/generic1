fun main(args: Array<String>) {
    var numbers=arrayOf<Int>() // Creates empty integer array - type restricted at compile time
    
    val footballPlayer=FootballPlayer(name="football player 1")
    val footballPlayer2=FootballPlayer(name="football player 2")
    val baseballPlayer=BaseballPlayer(name="Baseball player 1")
    val baseballPlayer2=BaseballPlayer(name="Baseball player 2")

    // Generic teams with type safety - prevents mixing player types
    val footballTeam=Team<FootballPlayer>(name="Football team",
        mutableListOf(footballPlayer))
    footballTeam.addPlayers(footballPlayer2) // ✅ Allowed: same FootballPlayer type

    val BaseballTeam=Team<BaseballPlayer>(name="BaseBall team",
        mutableListOf(baseballPlayer))
    BaseballTeam.addPlayers(baseballPlayer2) // ✅ Allowed: same BaseballPlayer type

    // baseballTeam.addPlayer(footballPlayer) // ❌ Compile error: type safety enforced

    // VARIANCE EXAMPLE using 'out' (covariance)
    // Using 'out' allows List<GamesPlayer> to be treated as List<Player>
    val gamesPlayerTeam=Team<Player>(name="Games team",
       mutableListOf<GamesPlayer>(GamesPlayer(name="GamesPlayer1"))) // ✅ Covariant assignment

    // CONTRAVARIANCE would use 'in' keyword instead (see class definition issue below)
    // val CounterStrikeTeam=Team<CounterStrikePlayer>(name="CS Team",
    //    players=mutableListOf<GamesPlayer>(GamesPlayer(name="Player1"))) // ❌ Would need 'in' in class
}

// PROBLEMATIC CLASS DESIGN - 'out' variance conflicts with mutability
// 'out' makes type parameter covariant (read-only/safe for returns)
class Team<T>(val name:String, val players: MutableList<out T>){ // 'out' = covariance
    
    // CONFLICT: 'out' says T can only be in OUTPUT positions, but here it's INPUT
    fun addPlayers(player :T) { // ❌ T is parameter (INPUT) but class has 'out' variance
        // Unsafe cast - T might not be Player without type bounds
        if (players.contains(player)){
            println("Player: ${(player as Player).name} is already in the team ${this.name}")
        } else {
            // players.add(player) // ❌ Can't add! 'out' makes list read-only
            println("Player: ${(player as Player).name} is already in the team ${this.name}")
        }
    }
}

open class Player(val name:String)
class FootballPlayer(name:String): Player(name)
class BaseballPlayer(name:String):Player(name)
open class GamesPlayer(name:String):Player(name)
class CounterStrikePlayer(name:String):GamesPlayer(name)

// SECOND main() function - ERROR: Can't have duplicate main() functions!
// Remove this duplicate or rename it
fun main(){ // ❌ DUPLICATE: Already have main(args: Array<String>) above
    val list=mutableListOf<String>("Hello World")
    
    // Type check with star projection (* = unknown type)
    if(list is List<*>){ // Checks if list is any kind of List (erased type check)
        println("list is a List")
    }
    
    val mixedList=mutableListOf(1,2,360,'a',"b","c","hello","world")
    
    // Using reified generic function - preserves type at runtime
    val specificList=getSpecificTypes<Int>(mixedList) // Extracts only Ints from mixed list
    println("Ints from mixed list: $specificList") // Output: [1, 2, 360]
}

// REIFIED GENERICS - preserves type information at runtime
// 'inline' + 'reified' allows type checking (element is T) at runtime
inline fun <reified T> getSpecificTypes(list:List<Any>): MutableList<T> {
    val specificList=mutableListOf<T>()
    for (element :Any in list){
        if (element is T){ // ✅ Runtime type check works because T is reified
            specificList.add(element) // Safe cast - compiler knows element is T
        }
    }
    return specificList
}
