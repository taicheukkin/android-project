```kotlin
// ============================================================
// KOTLIN groupBy() FUNCTION DEMONSTRATION
// Groups collection elements by a specified key
// ============================================================

fun main() {
    
    println("=== 1. BASIC LIST FOR GROUPING ===")
    
    // A list of string numbers for demonstration
    val numbers = listOf("one", "two", "three", "four", "five")
    println("Original list: $numbers")
    // Output: [one, two, three, four, five]
    
    println("\n=== 2. BASIC groupBy() ===")
    
    // ----------------------------------------------------
    // A) Simple groupBy() - Group by first character
    // ----------------------------------------------------
    // Syntax: collection.groupBy { keySelector }
    // Returns: Map<KeyType, List<ElementType>>
    // 
    // Process: For each element "one", "two", "three", etc.:
    // 1. Extract key: it.first().uppercase() → first character uppercase
    // 2. Add element to the list for that key in the resulting map
    
    val groupedByFirstChar = numbers.groupBy { element ->
        element.first().uppercase()  // Key: First character (uppercased)
    }
    
    println("groupBy { it.first().uppercase() }:")
    groupedByFirstChar.forEach { (key, values) ->
        println("  Key '$key' → $values")
    }
    // Output:
    // Key 'O' → [one]
    // Key 'T' → [two, three]
    // Key 'F' → [four, five]
    
    println("\nFull map structure: $groupedByFirstChar")
    // Output: {O=[one], T=[two, three], F=[four, five]}
    
    // ----------------------------------------------------
    // VISUAL REPRESENTATION OF THE GROUPING PROCESS
    // ----------------------------------------------------
    /*
    Original: ["one", "two", "three", "four", "five"]
    
    Step-by-step grouping:
    
    Element: "one"
      → Key: "one".first().uppercase() = "O"
      → Add to map: "O" → ["one"]
    
    Element: "two"  
      → Key: "two".first().uppercase() = "T"
      → Add to map: "T" → ["two"]
    
    Element: "three"
      → Key: "three".first().uppercase() = "T"
      → Map already has key "T" → Append to existing list
      → Map: "T" → ["two", "three"]
    
    Element: "four"
      → Key: "four".first().uppercase() = "F"  
      → Add to map: "F" → ["four"]
    
    Element: "five"
      → Key: "five".first().uppercase() = "F"
      → Map already has key "F" → Append to existing list
      → Map: "F" → ["four", "five"]
    
    Final Map: {
      "O" = ["one"],
      "T" = ["two", "three"], 
      "F" = ["four", "five"]
    }
    */
    
    println("\n=== 3. groupBy() WITH KEY & VALUE TRANSFORM ===")
    
    // ----------------------------------------------------
    // B) Advanced groupBy() with both key and value transforms
    // ----------------------------------------------------
    // Syntax: groupBy(keySelector, valueTransform)
    // Returns: Map<KeyType, List<TransformedValueType>>
    // 
    // Two transformations happen:
    // 1. keySelector: Transforms element to create map key
    // 2. valueTransform: Transforms element before adding to group list
    
    val groupedWithTransform = numbers.groupBy(
        keySelector = { element -> 
            element.first()  // Key: First character (LOWERCASE - no .uppercase())
        },
        valueTransform = { element ->
            element.lowercase()  // Value: Entire string converted to lowercase
        }
    )
    
    println("groupBy(keySelector={it.first()}, valueTransform={it.lowercase()}):")
    groupedWithTransform.forEach { (key, values) ->
        println("  Key '$key' → $values")
    }
    // Output:
    // Key 'o' → [one]      (Note: lowercase 'o' vs previous uppercase 'O')
    // Key 't' → [two, three]
    // Key 'f' → [four, five]
    
    println("\nFull map structure: $groupedWithTransform")
    // Output: {o=[one], t=[two, three], f=[four, five]}
    
    println("\n=== 4. COMPARING THE TWO RESULTS ===")
    
    println("Basic groupBy (uppercase keys):")
    println("  Keys: ${groupedByFirstChar.keys}")        // [O, T, F]
    println("  Values type: ${groupedByFirstChar["O"]?.let { it::class.simpleName }}") // ArrayList
    
    println("\nAdvanced groupBy (lowercase keys & values):")  
    println("  Keys: ${groupedWithTransform.keys}")      // [o, t, f]
    println("  All values lowercase: ${groupedWithTransform["f"]}") // [four, five]
    
    println("\n=== 5. MORE PRACTICAL EXAMPLES ===")
    
    // ----------------------------------------------------
    // Example 1: Group by string length
    // ----------------------------------------------------
    val groupedByLength = numbers.groupBy { it.length }
    println("1. Group by length:")
    groupedByLength.forEach { (length, words) ->
        println("   $length-letter words: $words")
    }
    // Output:
    //   3-letter words: [one, two]
    //   5-letter words: [three]
    //   4-letter words: [four, five]
    
    // ----------------------------------------------------
    // Example 2: Group by whether contains 'e'
    // ----------------------------------------------------
    val groupedByContainsE = numbers.groupBy { it.contains('e') }
    println("\n2. Group by contains 'e':")
    groupedByContainsE.forEach { (hasE, words) ->
        println("   Contains 'e' = $hasE: $words")
    }
    // Output:
    //   Contains 'e' = true: [one, three, five]
    //   Contains 'e' = false: [two, four]
    
    // ----------------------------------------------------
    // Example 3: Group with complex key (pair)
    // ----------------------------------------------------
    val groupedByFirstAndLast = numbers.groupBy { 
        Pair(it.first(), it.last())  // Key is a Pair(firstChar, lastChar)
    }
    println("\n3. Group by (firstChar, lastChar):")
    groupedByFirstAndLast.forEach { (pair, words) ->
        println("   Key (${pair.first}, ${pair.second}) → $words")
    }
    // Output:
    //   Key (o, e) → [one]
    //   Key (t, o) → [two]
    //   Key (t, e) → [three]  
    //   Key (f, r) → [four]
    //   Key (f, e) → [five]
    
    // ----------------------------------------------------
    // Example 4: Real-world - Group users by department
    // ----------------------------------------------------
    data class Employee(val name: String, val department: String, val salary: Int)
    
    val employees = listOf(
        Employee("Alice", "Engineering", 85000),
        Employee("Bob", "Sales", 65000),
        Employee("Charlie", "Engineering", 95000),
        Employee("Diana", "Marketing", 70000),
        Employee("Eve", "Sales", 60000)
    )
    
    val employeesByDept = employees.groupBy { it.department }
    
    println("\n4. Employees grouped by department:")
    employeesByDept.forEach { (dept, empList) ->
        val names = empList.joinToString { it.name }
        val avgSalary = empList.map { it.salary }.average().toInt()
        println("   $dept Department: $names (Avg salary: \$$avgSalary)")
    }
    // Output:
    //   Engineering Department: Alice, Charlie (Avg salary: $90000)
    //   Sales Department: Bob, Eve (Avg salary: $62500)
    //   Marketing Department: Diana (Avg salary: $70000)
    
    // ----------------------------------------------------
    // Example 5: Group with value transformation
    // ----------------------------------------------------
    val namesByDept = employees.groupBy(
        keySelector = { it.department },
        valueTransform = { it.name }  // Store only names, not full objects
    )
    
    println("\n5. Only employee names grouped by department:")
    println(namesByDept)
    // Output: {Engineering=[Alice, Charlie], Sales=[Bob, Eve], Marketing=[Diana]}
    
    println("\n=== 6. RELATED GROUPING FUNCTIONS ===")
    
    // ----------------------------------------------------
    // A) groupByTo() - Group into existing mutable map
    // ----------------------------------------------------
    val targetMap = mutableMapOf<String, MutableList<String>>()
    numbers.groupByTo(targetMap) { it.first().uppercase() }
    println("groupByTo (appends to existing map): $targetMap")
    
    // ----------------------------------------------------
    // B) groupingBy() - More advanced grouping (Kotlin 1.1+)
    // ----------------------------------------------------
    val grouping = numbers.groupingBy { it.first().uppercase() }
    println("\ngroupingBy() creates a Grouping object:")
    println("  Group sizes: ${grouping.eachCount()}")  // {O=1, T=2, F=2}
    
    // ----------------------------------------------------
    // C) associateBy() vs groupBy() - IMPORTANT DIFFERENCE!
    // ----------------------------------------------------
    println("\n=== groupBy() vs associateBy() DIFFERENCE ===")
    
    // groupBy() → Map<Key, List<Value>> (multiple values per key)
    val groupByResult = numbers.groupBy { it.first().uppercase() }
    println("groupBy(): $groupByResult")
    // Output: {O=[one], T=[two, three], F=[four, five]}
    
    // associateBy() → Map<Key, SingleValue> (last value wins if duplicate keys)
    val associateByResult = numbers.associateBy { it.first().uppercase() }
    println("associateBy(): $associateByResult")
    // Output: {O=one, T=three, F=five} (two/three share key T, three wins!)
    
    println("\nKey difference:")
    println("• groupBy() collects ALL values with same key into a List")
    println("• associateBy() keeps ONLY LAST value when keys duplicate")
    
    println("\n=== 7. REAL-WORLD USE CASES ===")
    
    // Use Case 1: Categorizing products
    val products = listOf("Laptop", "Mouse", "Keyboard", "Monitor", "Motherboard")
    val byCategory = products.groupBy {
        when {
            it.startsWith("M") -> "M-Peripherals"
            else -> "Other"
        }
    }
    println("1. Products by category: $byCategory")
    
    // Use Case 2: Grouping by date (e.g., events by month)
    data class Event(val name: String, val date: String) // YYYY-MM-DD format
    
    val events = listOf(
        Event("Conference", "2024-03-15"),
        Event("Workshop", "2024-03-20"),
        Event("Meetup", "2024-04-05"),
        Event("Seminar", "2024-03-25")
    )
    
    val eventsByMonth = events.groupBy { event ->
        event.date.substring(0, 7) // Extract YYYY-MM (year-month)
    }
    
    println("\n2. Events grouped by month:")
    eventsByMonth.forEach { (month, eventList) ->
        println("   $month: ${eventList.joinToString { it.name }}")
    }
    
    // Use Case 3: Grouping for statistics
    val scores = listOf(85, 92, 78, 95, 88, 72, 91, 84, 79, 96)
    val scoresByRange = scores.groupBy { score ->
        when (score) {
            in 90..100 -> "A (90-100)"
            in 80..89 -> "B (80-89)"
            in 70..79 -> "C (70-79)"
            else -> "Below 70"
        }
    }
    
    println("\n3. Score distribution:")
    scoresByRange.forEach { (range, scoreList) ->
        println("   $range: ${scoreList.size} students")
    }
}

// ============================================================
// QUICK REFERENCE GUIDE
// ============================================================
/*
GROUPBY() FUNCTION SIGNATURES:

1. Basic: 
   collection.groupBy { keySelector }
   Returns: Map<Key, List<Element>>
   
2. With value transform:
   collection.groupBy(keySelector, valueTransform)  
   Returns: Map<Key, List<TransformedValue>>

KEY CONCEPTS:
- Creates a Map where keys come from keySelector
- Values are Lists of elements (or transformed elements)
- Elements with same key are grouped together in a list
- Original collection order is preserved within groups

COMMON USE CASES:
1. Categorization (group by category/tag/type)
2. Aggregation (count, sum, average within groups)
3. Partitioning (split data into logical groups)
4. Data summarization (create summary by key)

PERFORMANCE:
- Time complexity: O(n) - processes each element once
- Space complexity: O(n) - creates new map and lists
- For large datasets, consider using sequences

ALTERNATIVES:
- groupingBy(): More advanced operations (fold, reduce, aggregate)
- associateBy(): When you need one-to-one mapping (keys unique)
- partition(): For binary grouping (true/false conditions)
*/
```kotlin
